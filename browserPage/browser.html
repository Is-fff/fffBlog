<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>宏任务与微任务 | 吴炫境个人博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="代码学习记录">
    
    <link rel="preload" href="/fffBlog/assets/css/0.styles.a74e95d9.css" as="style"><link rel="preload" href="/fffBlog/assets/js/app.cec7b3d6.js" as="script"><link rel="preload" href="/fffBlog/assets/js/2.92b40a62.js" as="script"><link rel="preload" href="/fffBlog/assets/js/1.40f520a9.js" as="script"><link rel="preload" href="/fffBlog/assets/js/16.9e0b3e50.js" as="script"><link rel="prefetch" href="/fffBlog/assets/js/10.0c61e136.js"><link rel="prefetch" href="/fffBlog/assets/js/11.2c20532d.js"><link rel="prefetch" href="/fffBlog/assets/js/12.c582b446.js"><link rel="prefetch" href="/fffBlog/assets/js/13.207a685b.js"><link rel="prefetch" href="/fffBlog/assets/js/14.1fdf4a2a.js"><link rel="prefetch" href="/fffBlog/assets/js/15.9fb4f1ad.js"><link rel="prefetch" href="/fffBlog/assets/js/17.aba044a2.js"><link rel="prefetch" href="/fffBlog/assets/js/18.beba6154.js"><link rel="prefetch" href="/fffBlog/assets/js/19.fe18b34a.js"><link rel="prefetch" href="/fffBlog/assets/js/20.d016de69.js"><link rel="prefetch" href="/fffBlog/assets/js/21.bedebcf0.js"><link rel="prefetch" href="/fffBlog/assets/js/22.0942125b.js"><link rel="prefetch" href="/fffBlog/assets/js/23.2b2a8dca.js"><link rel="prefetch" href="/fffBlog/assets/js/24.b8a35182.js"><link rel="prefetch" href="/fffBlog/assets/js/25.f57de6ea.js"><link rel="prefetch" href="/fffBlog/assets/js/26.d9494331.js"><link rel="prefetch" href="/fffBlog/assets/js/27.db387258.js"><link rel="prefetch" href="/fffBlog/assets/js/28.ca541479.js"><link rel="prefetch" href="/fffBlog/assets/js/29.70adba3c.js"><link rel="prefetch" href="/fffBlog/assets/js/3.182c257f.js"><link rel="prefetch" href="/fffBlog/assets/js/30.02c8b825.js"><link rel="prefetch" href="/fffBlog/assets/js/31.1ccc7f5f.js"><link rel="prefetch" href="/fffBlog/assets/js/32.79b32ca7.js"><link rel="prefetch" href="/fffBlog/assets/js/33.e45d1bf9.js"><link rel="prefetch" href="/fffBlog/assets/js/34.58b6d383.js"><link rel="prefetch" href="/fffBlog/assets/js/35.e356d625.js"><link rel="prefetch" href="/fffBlog/assets/js/36.795ee075.js"><link rel="prefetch" href="/fffBlog/assets/js/37.bb6c6325.js"><link rel="prefetch" href="/fffBlog/assets/js/4.a29c46b6.js"><link rel="prefetch" href="/fffBlog/assets/js/5.e6661a5c.js"><link rel="prefetch" href="/fffBlog/assets/js/6.4c5bfda8.js"><link rel="prefetch" href="/fffBlog/assets/js/7.f22cdc7f.js"><link rel="prefetch" href="/fffBlog/assets/js/vendors~docsearch.11055bee.js">
    <link rel="stylesheet" href="/fffBlog/assets/css/0.styles.a74e95d9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/fffBlog/" class="home-link router-link-active"><!----> <span class="site-name">吴炫境个人博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/fffBlog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端基础" class="dropdown-title"><span class="title">前端基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端基础" class="mobile-dropdown-title"><span class="title">前端基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/html.html" class="nav-link">
  HTML5
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/Js.html" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/css.html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/ES6.html" class="nav-link">
  ES6新特性
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/ts.html" class="nav-link">
  TypeScript
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/something.html" class="nav-link">
  杂记
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端框架" class="dropdown-title"><span class="title">前端框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端框架" class="mobile-dropdown-title"><span class="title">前端框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fffBlog/FrameworkPage/index.html" class="nav-link">
  框架概述
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/FrameworkPage/vue.html" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/FrameworkPage/react.html" class="nav-link">
  React
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="构建工具" class="dropdown-title"><span class="title">构建工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="构建工具" class="mobile-dropdown-title"><span class="title">构建工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fffBlog/toolPage/webpack.html" class="nav-link">
  webpack
</a></li></ul></div></div><div class="nav-item"><a href="/fffBlog/browserPage/browser.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  浏览器相关
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机系统" class="dropdown-title"><span class="title">计算机系统</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机系统" class="mobile-dropdown-title"><span class="title">计算机系统</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fffBlog/CNTPage/cnt.html" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/CNTPage/algorithm.html" class="nav-link">
  算法
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/CNTPage/dataStructure.html" class="nav-link">
  数据结构
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/fffBlog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端基础" class="dropdown-title"><span class="title">前端基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端基础" class="mobile-dropdown-title"><span class="title">前端基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/html.html" class="nav-link">
  HTML5
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/Js.html" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/css.html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/ES6.html" class="nav-link">
  ES6新特性
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/ts.html" class="nav-link">
  TypeScript
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/something.html" class="nav-link">
  杂记
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端框架" class="dropdown-title"><span class="title">前端框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端框架" class="mobile-dropdown-title"><span class="title">前端框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fffBlog/FrameworkPage/index.html" class="nav-link">
  框架概述
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/FrameworkPage/vue.html" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/FrameworkPage/react.html" class="nav-link">
  React
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="构建工具" class="dropdown-title"><span class="title">构建工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="构建工具" class="mobile-dropdown-title"><span class="title">构建工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fffBlog/toolPage/webpack.html" class="nav-link">
  webpack
</a></li></ul></div></div><div class="nav-item"><a href="/fffBlog/browserPage/browser.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  浏览器相关
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机系统" class="dropdown-title"><span class="title">计算机系统</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机系统" class="mobile-dropdown-title"><span class="title">计算机系统</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fffBlog/CNTPage/cnt.html" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/CNTPage/algorithm.html" class="nav-link">
  算法
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/CNTPage/dataStructure.html" class="nav-link">
  数据结构
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>宏任务与微任务</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fffBlog/browserPage/browser.html#宏任务与微任务" class="sidebar-link">宏任务与微任务</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fffBlog/browserPage/browser.html#浏览器事件循环" class="sidebar-link">浏览器事件循环</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fffBlog/browserPage/browser.html#nodejs的事件循环eventloop详解" class="sidebar-link">Nodejs的事件循环EventLoop详解</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fffBlog/browserPage/browser.html#浏览器事件循环和nodejs事件循环的区别" class="sidebar-link">浏览器事件循环和Nodejs事件循环的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fffBlog/browserPage/browser.html#浏览器如何渲染页面" class="sidebar-link">浏览器如何渲染页面</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fffBlog/browserPage/browser.html#浏览器加载js脚本" class="sidebar-link">浏览器加载JS脚本</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fffBlog/browserPage/browser.html#script标签的defer和async属性" class="sidebar-link">Script标签的defer和async属性</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fffBlog/browserPage/browser.html#从输入url到呈现页面过程" class="sidebar-link">从输入URL到呈现页面过程</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fffBlog/browserPage/browser.html#web常见网络安全漏洞以及解决" class="sidebar-link">Web常见网络安全漏洞以及解决</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#xss-跨站脚本攻击" class="sidebar-link">XSS(跨站脚本攻击)</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#sql注入" class="sidebar-link">SQL注入</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#点击劫持" class="sidebar-link">点击劫持</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#csrf-cross-site-request-forgery-跨站请求伪造" class="sidebar-link">CSRF (Cross-site request forgery，跨站请求伪造)</a></li></ul></li><li><a href="/fffBlog/browserPage/browser.html#token生成原理" class="sidebar-link">Token生成原理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fffBlog/browserPage/browser.html#跨域" class="sidebar-link">跨域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#什么是跨域" class="sidebar-link">什么是跨域</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#为什么要跨域拦截" class="sidebar-link">为什么要跨域拦截</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#运行跨域的请求" class="sidebar-link">运行跨域的请求</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#跨域了请求发出去了吗" class="sidebar-link">跨域了请求发出去了吗？</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#那为什么表单能够跨域发送请求-而-ajax-却不能发送跨域请求" class="sidebar-link">那为什么表单能够跨域发送请求，而 Ajax 却不能发送跨域请求</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#解决跨域的方法" class="sidebar-link">解决跨域的方法</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#websocket和http的联系" class="sidebar-link">WebSocket和HTTP的联系</a></li></ul></li><li><a href="/fffBlog/browserPage/browser.html#前端缓存" class="sidebar-link">前端缓存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#分类-优先级高-优先级低" class="sidebar-link">分类(优先级高-&gt;优先级低)</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#浏览器请求一个静态资源的完整流程" class="sidebar-link">浏览器请求一个静态资源的完整流程：</a></li></ul></li><li><a href="/fffBlog/browserPage/browser.html#强缓存、协商缓存、cdn缓存" class="sidebar-link">强缓存、协商缓存、CDN缓存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#cdn的概念-content-delivery-network" class="sidebar-link">CDN的概念（Content Delivery Network）</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#cdn的作用" class="sidebar-link">CDN的作用</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#加载流程" class="sidebar-link">加载流程</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#使用场景" class="sidebar-link">使用场景</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#强缓存" class="sidebar-link">强缓存</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#协商缓存" class="sidebar-link">协商缓存</a></li></ul></li><li><a href="/fffBlog/browserPage/browser.html#跨域时如何处理cookie" class="sidebar-link">跨域时如何处理cookie</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fffBlog/browserPage/browser.html#iframe的缺点-弊端" class="sidebar-link">iframe的缺点，弊端</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fffBlog/browserPage/browser.html#sessionstorage、localstorage、cookies、session的区别" class="sidebar-link">SessionStorage、LocalStorage、Cookies、Session的区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#作用域的区别" class="sidebar-link">作用域的区别</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#作用时间的区别" class="sidebar-link">作用时间的区别</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#存储位置的区别" class="sidebar-link">存储位置的区别</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#传输数据" class="sidebar-link">传输数据</a></li></ul></li><li><a href="/fffBlog/browserPage/browser.html#localstorage和indexeddb" class="sidebar-link">LocalStorage和indexedDB</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#同" class="sidebar-link">同</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#异" class="sidebar-link">异</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#indexeddb" class="sidebar-link">indexedDB</a></li></ul></li><li><a href="/fffBlog/browserPage/browser.html#spa" class="sidebar-link">SPA</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#概念" class="sidebar-link">概念</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#优点" class="sidebar-link">优点</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#缺点" class="sidebar-link">缺点</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#解决首屏加载慢问题" class="sidebar-link">解决首屏加载慢问题</a></li></ul></li><li><a href="/fffBlog/browserPage/browser.html#浏览器内核" class="sidebar-link">浏览器内核</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#渲染引擎" class="sidebar-link">渲染引擎</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#js引擎" class="sidebar-link">js引擎</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#常见内核" class="sidebar-link">常见内核</a></li></ul></li><li><a href="/fffBlog/browserPage/browser.html#前端监控" class="sidebar-link">前端监控</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#捕获网络异常错误" class="sidebar-link">捕获网络异常错误</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#捕获未处理的promise错误" class="sidebar-link">捕获未处理的Promise错误</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#捕获js同步错误" class="sidebar-link">捕获JS同步错误</a></li></ul></li><li><a href="/fffBlog/browserPage/browser.html#前端性能指标" class="sidebar-link">前端性能指标</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fffBlog/browserPage/browser.html#前端预加载" class="sidebar-link">前端预加载</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#概念-2" class="sidebar-link">概念</a></li><li class="sidebar-sub-header"><a href="/fffBlog/browserPage/browser.html#实现" class="sidebar-link">实现</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="宏任务与微任务"><a href="#宏任务与微任务" class="header-anchor">#</a> 宏任务与微任务</h2> <p><strong>宏任务</strong>：(macro)task，可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行），主要包括：script(整体代码)、setTimeout、setInterval、XMLHttpRequest.prototype.onload、I/O、UI 渲染。（由宿主发起的【Node/浏览器】）</p> <p><strong>微任务</strong>：微任务（microtask）是宏任务中的一个部分，它的执行时机是在同步代码执行之后，下一个宏任务执行之前。主要包括：Promise、MutationObserver。（由js发起的）</p> <h2 id="浏览器事件循环"><a href="#浏览器事件循环" class="header-anchor">#</a> 浏览器事件循环</h2> <p>l 所有同步任务都在主线程上执行（单线程），形成一个 “执行栈”（execution context stack）；</p> <p>l 主线程之外，存在一个 “任务队列”（task queue），在走主流程的时候，如果碰到异步任务，那么就在 “任务队列” 中放置这个异步任务；</p> <p>l 一旦 “执行栈” 中所有同步任务执行完毕，系统就会读取 “任务队列”，看看里面存在哪些事件。那些对应的异步任务，结束等待状态，进入执行栈，开始执行；</p> <p>主线程不断重复上面三个步骤；</p> <p>执行次序：同步代码-&gt;微任务代码-&gt;宏任务代码-&gt;宏任务代码中的下一个同步代码-&gt;下一个微任务代码-&gt;……循环</p> <p>总结：执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。</p> <p><strong>重点！！！</strong></p> <p>并不是会清空所有宏任务队列的内容，而是每一个宏任务执行完后，都会去清空微任务队列，才去执行下一个宏任务。</p> <h2 id="nodejs的事件循环eventloop详解"><a href="#nodejs的事件循环eventloop详解" class="header-anchor">#</a> Nodejs的事件循环EventLoop详解</h2> <p>大体上和浏览器相同，但是多了一些Api</p> <p>例如：IO操作，setImmediate()，process.nextTick</p> <p>nodejs中，宏任务的执行也是分阶段的</p> <p><img src="/fffBlog/assets/img/nodejsEventLoop.3de24a86.png" alt="img"></p> <div class="language- extra-class"><pre class="language-text"><code>1.timers: 执行setTimeout和setInterval的回调
2.pending callbacks: 执行延迟到下一个循环迭代的 I/O 回调
3.idle,prepare: 仅系统内部使用
4.poll: 检索新的 I/O 事件;执行与 I/O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。
5.check: setImmediate在这里执行
6.close callbacks: 一些关闭的回调函数，如：socket.on('close', ...)
</code></pre></div><p><strong>重点来了！！！</strong></p> <p>timers会将计时器到期的任务都放在这里面执行</p> <p>poll是大部分的IO回调</p> <p>check是Immediate的特殊执行时机</p> <p><strong>由于</strong></p> <p>process.nextTick(),属于微任务，并且执行时机又是所有微任务之前，因此，不管宏任务处于哪一个阶段，执行完一个任务之后，就马上执行nextTick</p> <p>setImmediate被认为说是在下一次事件循环之前触发，但是执行顺序其实是遵循这个阶段的顺序</p> <p>案例</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'outer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">//执行到这里，此时是timer阶段</span>
  <span class="token comment">//js中setTimeout为0时，会被强制改为1ms,因此只能进入计时器线程，时间到了也只能进入下一个循环的timer</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//遇到setImmediate,因为本次循环的check阶段还没开始，所以进入check阶段</span>
  <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setImmediate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//执行完timer阶段了，接下来 pending,idle,poll,check(所以输出setImmediate),close</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//输出</span>
<span class="token comment">//outer    setImmediate    setTimeout </span>
</code></pre></div><p>案例</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'outer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//此时同步代码执行完，刚要进入timer阶段</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//由于0会被改成1ms,所以当程序在进入timer阶段之前，经过了1ms,那么这个回调就会出现在timer,就比setImmediate先执行</span>
<span class="token comment">//如果机器状态较好，进入timer前1ms还没到，那这个回调只能进入下一个循环的timer了，所以setImmediate就比较快</span>
<span class="token comment">//放进去check阶段</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setImmediate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//输出</span>
<span class="token comment">//outer 有可能先setImmediate,也可能先setTimeout</span>
</code></pre></div><p><strong>牢记！！！，setTimeout()的时间为0时，会被nodejs强制改成1，所以不是立即执行的</strong></p> <h2 id="浏览器事件循环和nodejs事件循环的区别"><a href="#浏览器事件循环和nodejs事件循环的区别" class="header-anchor">#</a> 浏览器事件循环和Nodejs事件循环的区别</h2> <p>浏览器：一个宏任务 -----&gt;  清空微任务  ------&gt;  下一个宏任务</p> <p>nodejs: 一个阶段  ---&gt;  清空微任务  -----&gt;  下一个阶段（一个阶段可能有多个宏任务，如timer有多个setTimeout回调，必须全部执行完，再执行微任务）</p> <h2 id="浏览器如何渲染页面"><a href="#浏览器如何渲染页面" class="header-anchor">#</a> 浏览器如何渲染页面</h2> <p>第一步构建DOM，第二步构建CSSOM，第三步构建渲染树，第四步布局，第五步绘制。如果构建DOM的时候遇到了JS，就请求下载执行JS。JS如果没有额外的设置，默认要等CSSOM构建完成。而JS既可以对DOM，也可以对CSSOM进行修改，这样后面的三步又会再运行一次。（DOM可以部分解析而CSS必须全部解析）</p> <p><img src="/fffBlog/assets/img/browserRender.5479864a.png" alt="img"></p> <h2 id="浏览器加载js脚本"><a href="#浏览器加载js脚本" class="header-anchor">#</a> 浏览器加载JS脚本</h2> <p>默认情况下，浏览器是<strong>同步加载 JavaScript 脚本的</strong>，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。</p> <p>问题：如果脚本很大，会导致浏览器渲染被阻塞很久，造成不好的体验</p> <p>解决：提供了两种异步加载js脚本的方法：defer和async属性</p> <p>script标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p> <div class="language-html extra-class"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>path/to/myModule.js<span class="token punctuation">&quot;</span></span> <span class="token attr-name">defer</span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>path/to/myModule.js<span class="token punctuation">&quot;</span></span> <span class="token attr-name">async</span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>区别：</p> <p><code>defer</code>要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；</p> <p><code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。</p> <p>即:defer是渲染完执行，async是下载完就执行</p> <h2 id="script标签的defer和async属性"><a href="#script标签的defer和async属性" class="header-anchor">#</a> Script标签的defer和async属性</h2> <p><img src="/fffBlog/assets/img/asyncdefer.f1c1165c.png" alt="img"></p> <p>defer:异步加载js，等待dom树构建完成，再执行脚本，始终DOMContextLoaded之前执行，多个defer会顺序执行</p> <p>async:异步加载异步执行，多个async不保证顺序执行，不保证在DOMContextLoaded之前执行</p> <p>都只适用于外部脚本</p> <h2 id="从输入url到呈现页面过程"><a href="#从输入url到呈现页面过程" class="header-anchor">#</a> 从输入URL到呈现页面过程</h2> <p>输入url</p> <p>缓存解析</p> <p>域名解析（递归查找，迭代查找）</p> <p>建立TCP连接（三次握手）</p> <p>客户端发起请求</p> <p>服务端接收请求并处理返回数据</p> <p>关闭TCP连接（四次挥手）</p> <p>浏览器渲染页面</p> <h2 id="web常见网络安全漏洞以及解决"><a href="#web常见网络安全漏洞以及解决" class="header-anchor">#</a> Web常见网络安全漏洞以及解决</h2> <h3 id="xss-跨站脚本攻击"><a href="#xss-跨站脚本攻击" class="header-anchor">#</a> <strong>XSS(跨站脚本攻击)</strong></h3> <p>通过文本输入注入恶意脚本，随输入提交到服务器，服务器保存脚本信息，当用户获取服务器数据时就会执行恶意脚本，侵害用户信息</p> <p><strong>解决</strong>：</p> <p>1.将cookie等敏感信息设置为HttpOnly，不允许通过document，js获取cookie，防止恶意脚本获取用户登陆信息。</p> <p>2.采用CSP内容安全策略，限制浏览器加载资源的类型和来源</p> <p>3.输入检测过滤，内容转义</p> <h3 id="sql注入"><a href="#sql注入" class="header-anchor">#</a> <strong>SQL注入</strong></h3> <p>当Web程序对数据输入没有做严格校验时，攻击者会在程序定义好的查询语句中插入恶意sql，实现任意查询，窃取数据。</p> <div class="language-sql extra-class"><pre class="language-sql"><code>eg:
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> username<span class="token operator">=</span><span class="token string">''</span> <span class="token operator">and</span> password<span class="token operator">=</span><span class="token string">''</span><span class="token comment">//本来要查询的语句</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> username<span class="token operator">=</span><span class="token string">''</span> <span class="token operator">and</span> password<span class="token operator">=</span><span class="token string">''</span> <span class="token operator">OR</span> <span class="token string">'1'</span><span class="token operator">=</span><span class="token string">'1'</span><span class="token comment">//密码设置为' OR '1'='1</span>
导致条件始终成立，绕过了密码验证
</code></pre></div><p>解决：</p> <p>1.避免直接拼接sql语句，采用参数化查询</p> <p>2.输入验证，拒绝非法字符输入</p> <p>3.最小权限原则，限制用户对数据库的访问权限</p> <p>4.输入过滤</p> <h3 id="点击劫持"><a href="#点击劫持" class="header-anchor">#</a> <strong>点击劫持</strong></h3> <p>攻击者使用一个多个的透明的iframe(嵌入式网页框架)覆盖在正常的网页上，诱导用户对该网页进行操作从而劫持用户的页面点击事件触发恶意回调或者进入恶意链接。</p> <p>解决：X-Frame-Options(一个http响应头部)，专门用来预防iframe攻击，deny,sameorigin,allow-from.</p> <h3 id="csrf-cross-site-request-forgery-跨站请求伪造"><a href="#csrf-cross-site-request-forgery-跨站请求伪造" class="header-anchor">#</a> <strong>CSRF</strong> (Cross-site request forgery，<strong>跨站请求伪造</strong>)</h3> <p>也被称为One Click Attack或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本(XSS)，但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装成受信任用户请求受信任的网站。</p> <p><img src="/fffBlog/assets/img/csrf.0ed13a27.png" alt="img"></p> <p><strong>攻击条件：</strong></p> <ul><li>登录受信任站点A，并在本地生成Cookie。</li> <li>在不登出A的情况下，访问危急站点B。</li></ul> <p><strong>防御</strong>：</p> <p>1、验证码</p> <p>验证码被认为是对抗CSRF攻击最简洁而有效的防御方法。</p> <p>2、在请求地址中添加 token 并验证</p> <p>可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p> <p>3、在 HTTP 头中自定义属性并验证</p> <p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。</p> <p>4、验证 HTTP Referer 字段</p> <p>根据 HTTP 协议，在 HTTP 头中有一个字段叫Referer，它记录了该 HTTP 请求的来源地址。</p> <h2 id="token生成原理"><a href="#token生成原理" class="header-anchor">#</a> Token生成原理</h2> <p>使用JWT生成(json web token),jwt包含了头部，载荷和签名三部分，头部和载荷经过base64编码存放token类型，加密算法（头部），授权时间，有效期（载荷），再用算法对签名进行加密，三个部分拼接生成token。</p> <h2 id="跨域"><a href="#跨域" class="header-anchor">#</a> 跨域</h2> <h3 id="什么是跨域"><a href="#什么是跨域" class="header-anchor">#</a> 什么是跨域</h3> <p>协议，域名，端口，任何一个不同都是跨域</p> <h3 id="为什么要跨域拦截"><a href="#为什么要跨域拦截" class="header-anchor">#</a> 为什么要跨域拦截</h3> <p>不进行跨域拦截很容易受到XSS,CSRF攻击</p> <h3 id="运行跨域的请求"><a href="#运行跨域的请求" class="header-anchor">#</a> 运行跨域的请求</h3> <p>img，link，script标签加载资源，以及表单提交是不受同源策略限制的</p> <h3 id="跨域了请求发出去了吗"><a href="#跨域了请求发出去了吗" class="header-anchor">#</a> 跨域了请求发出去了吗？</h3> <p>跨域并不是请求发送不出去，请求能发送产前样，服务端能收到请求并正常返回结果，只不过<strong>结果被浏览器拦截了</strong></p> <h3 id="那为什么表单能够跨域发送请求-而-ajax-却不能发送跨域请求"><a href="#那为什么表单能够跨域发送请求-而-ajax-却不能发送跨域请求" class="header-anchor">#</a> 那为什么表单能够跨域发送请求，而 Ajax 却不能发送跨域请求</h3> <p>归根结底：<strong>跨域是为了阻止用户读取到另一个域名下的内容</strong></p> <p>而 Ajax 可以获取响应，但浏览器认为这不安全，所以拦截了响应</p> <p>但是表单并不会获取新的内容，所以可以发起跨域请求。</p> <h3 id="解决跨域的方法"><a href="#解决跨域的方法" class="header-anchor">#</a> 解决跨域的方法</h3> <p>1.JSONP</p> <p>利用scirpt标签的跨域特性，向服务器发起请求，服务器返回一段带参数的js代码，实现跨域加载资源</p> <div class="language-html extra-class"><pre class="language-html"><code>//前端
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
	<span class="token keyword">const</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http:abcd.com<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>script&gt;
//后端服务器 http:abcd.com返回字符串fn(&quot;我是传输数据&quot;)
</code></pre></div><p>优点：兼容性好</p> <p>缺点：仅支持get请求，不安全易遭受XSS攻击(不支持Https)</p> <p>2.CORS  &quot;跨域资源共享&quot;（Cross-origin resource sharing）</p> <p>CORS 需要浏览器和服务器同时支持。但是目前基本上浏览器都支持，所以我们<strong>只要保证服务器端服务器实现了 CORS 接口，就可以跨源通信</strong></p> <p>后端：</p> <table><thead><tr><th style="text-align:left;">Name</th> <th style="text-align:left;">Required</th> <th style="text-align:left;">Comments</th></tr></thead> <tbody><tr><td style="text-align:left;">Access-Control-Allow-Origin</td> <td style="text-align:left;">必填</td> <td style="text-align:left;">允许请求的域</td></tr> <tr><td style="text-align:left;">Access-Control-Allow-Methods</td> <td style="text-align:left;">必填</td> <td style="text-align:left;">允许请求的方法</td></tr> <tr><td style="text-align:left;">Access-Control-Allow-Headers</td> <td style="text-align:left;">可选</td> <td style="text-align:left;">预检请求后，告知发送请求需要有的头部</td></tr> <tr><td style="text-align:left;">Access-Control-Allow-Credentials</td> <td style="text-align:left;">可选</td> <td style="text-align:left;">表示是否允许发送cookie，默认false；</td></tr> <tr><td style="text-align:left;">Access-Control-Max-Age</td> <td style="text-align:left;">可选</td> <td style="text-align:left;">本次预检的有效期，单位：秒；</td></tr></tbody></table> <p>3.postMessage()</p> <p>对iframe跨域来说：H5提供了postMessage()的方法，可以在父子页面进行通信</p> <p>4.使用Websocket通信</p> <p>WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p> <h3 id="websocket和http的联系"><a href="#websocket和http的联系" class="header-anchor">#</a> WebSocket和HTTP的联系</h3> <blockquote><p><strong>相同点：</strong></p> <ol><li><strong>都是基于tcp的，都是可靠性传输协议</strong></li> <li><strong>都是应用层协议</strong></li></ol></blockquote> <blockquote><p><strong>不同点：</strong></p> <ol><li><strong>WebSocket是双向通信协议，模拟Socket协议，可以<u>双向发送或接受信息</u></strong></li> <li><strong>HTTP是<u>单向</u>的</strong></li> <li><strong>WebSocket是需要浏览器和服务器握手进行建立连接的</strong></li> <li><strong>而http是浏览器发起向服务器的连接，服务器预先并不知道这个连接</strong>，需要客户端主动发，服务端被动发，也就是一次请求，一次响应</li></ol></blockquote> <h2 id="前端缓存"><a href="#前端缓存" class="header-anchor">#</a> 前端缓存</h2> <h3 id="分类-优先级高-优先级低"><a href="#分类-优先级高-优先级低" class="header-anchor">#</a> 分类(优先级高-&gt;优先级低)</h3> <h4 id="service-worker"><a href="#service-worker" class="header-anchor">#</a> Service Worker</h4> <p>Service Worker 借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问DOM。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是 Service Worker Cache。</p> <p>浏览器调试窗口：Application-&gt;Cache Storage</p> <h4 id="memory-cache"><a href="#memory-cache" class="header-anchor">#</a> Memory cache</h4> <p>内存缓存，几乎所有的网络请求资源都会被浏览器自动加入到 memory cache 中。而如果极端情况下 (例如一个页面的缓存就占用了超级多的内存)，那可能在 TAB 没关闭之前，排在前面的缓存就已经失效了。设置Cache:no-store不缓存，页面关闭缓存清除。</p> <p>存取速度快，容量较小</p> <h4 id="disk-cache"><a href="#disk-cache" class="header-anchor">#</a> disk cache</h4> <p>磁盘缓存，也叫Http缓存。磁盘缓存比内存缓存的存取速度慢。大文件一般都要放在磁盘缓存而不是内存缓存，通过请求头来指定</p> <p>存取速度较慢，容量较大</p> <p><strong>memory cache和disk cache统称强缓存</strong></p> <h3 id="浏览器请求一个静态资源的完整流程"><a href="#浏览器请求一个静态资源的完整流程" class="header-anchor">#</a> 浏览器请求一个静态资源的完整流程：</h3> <ol><li><p>调用 Service Worker 的 fetch 事件响应</p></li> <li><p>查看 memory cache</p></li> <li><p>查看 disk cache。这里又细分：</p></li> <li><p>如果有强制缓存且未失效，则使用强制缓存，不请求服务器。这时的状态码全部是 200</p></li> <li><p>如果有强制缓存但已失效，使用协商缓存，比较后确定 304 还是 200</p></li> <li><p>发送网络请求，等待网络响应</p></li> <li><p>把响应内容存入 disk cache (如果 HTTP 头信息配置可以存的话)</p></li> <li><p>把响应内容的引用存入 memory cache (无视 HTTP 头信息的配置)</p></li> <li><p>把响应内容存入 Service Worker 的 Cache Storage (如果 Service Worker 的脚本调用了 cache.put())</p></li></ol> <h2 id="强缓存、协商缓存、cdn缓存"><a href="#强缓存、协商缓存、cdn缓存" class="header-anchor">#</a> 强缓存、协商缓存、CDN缓存</h2> <h3 id="cdn的概念-content-delivery-network"><a href="#cdn的概念-content-delivery-network" class="header-anchor">#</a> CDN的概念（Content Delivery Network）</h3> <p>CDN（内容分发网络）通过一组位于全球各地的服务器，将网站的内容（例如图片、视频、网页文件等）从最靠近用户的服务器快速、可靠地发送给用户，从而提供快速、高效、低成本的内容传输服务。CDN系统通常由三个主要部分组成：分发服务系统，负载平衡系统，运营管理系统</p> <h3 id="cdn的作用"><a href="#cdn的作用" class="header-anchor">#</a> CDN的作用</h3> <ol><li>加速网站加载速度：CDN会将网站的图片、视频和其他静态资源缓存在离用户更近的服务器上，这样用户在访问网站时可以从附近的服务器获取这些内容，从而加快网站加载速度。</li> <li>减少网络延迟：由于用户能够从距离更近的服务器获取内容，CDN可以减少网络延迟，提高网站的响应速度，让用户能够更快地打开网页和浏览内容。</li> <li>减轻服务器负载：部分用户的访问请求会被分配给CDN的服务器处理，这样可以减轻原始服务器的负载压力，提高服务器的性能和稳定性。</li> <li>节省带宽成本：CDN可以减少网站跨地区传输的流量，降低网站的带宽成本，使网站运营更加经济高效。</li> <li>提高安全性：CDN还有助于提高网站的安全性，能够抵御一些网络攻击，例如通过监控异常流量来防御DDoS攻击，以及通过全链路HTTPS通信来防范中间人攻击。</li></ol> <h3 id="加载流程"><a href="#加载流程" class="header-anchor">#</a> 加载流程</h3> <ol><li>用户向本地DNS服务器发起DNS请求解析域名</li> <li>配置了CDN的域名会解析出一个CName,DNS服务器将域名解析权交给CName指定的DNS域名服务器（重定向）</li> <li>DNS解析域名，返回全局负载均衡设备的IP给浏览器</li> <li>浏览器向IP发起HTTP请求得到边缘节点的IP并与该节点通信取得内容</li></ol> <h3 id="使用场景"><a href="#使用场景" class="header-anchor">#</a> 使用场景</h3> <ol><li><p><strong>网站加速</strong>：通过将<strong>静态资源如图片、视频、样式表等放在CDN上</strong>，用户可以从距离更近的CDN服务器获取这些资源，从而加快网页加载速度，改善用户体验。</p></li> <li><p><strong>流媒体分发</strong>：CDN可用于快速、可靠地传输视频、音频等大型媒体文件到全球各地的用户设备，确保用户可以流畅观看视频、听取音频。</p></li> <li><p>软件分发：对于大型软件或游戏的发布与更新，CDN能够快速地将软件分发到全球各地的用户，减少下载时间，加快软件更新的部署。</p></li> <li><p>API请求加速：对于需要频繁请求后端API的网站和应用程序，CDN能够加速API的响应时间，提高系统的稳定性和性能。</p></li> <li><p>跨地区网络优化：对于跨地区的企业、服务提供商等，CDN能够优化全球网络传输，提高数据传输效率，降低网络延迟，改善数据传输质量。</p></li> <li><p>第三方CDN服务：开发者可以使用第三方CDN服务来加速其开源项目的网络传输和加载速度。</p></li> <li><p>直播传送：CDN也支持直播传送，通过在全球范围内部署服务器来提高访问速度，确保用户可以流畅观看直播内容。</p></li></ol> <h3 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> 强缓存</h3> <p>强缓存指的是在缓存有效期内，<strong>不需要向服务器发送请求</strong>，直接从缓存中读取资源。这意味着在缓存有效期内，浏览器直接使用缓存的资源，不会与服务器通信。</p> <p><strong>好处</strong>
减少服务器负载：减少了不必要的请求，服务器负载显著降低。
提高页面加载速度：资源直接从本地缓存中读取，减少了网络延迟，页面加载速度更快。
节省带宽：避免重复下载相同的资源，节省了带宽资源。
改善用户体验：快速的页面加载提高了用户满意度和留存率。
<strong>如何开启</strong>
强缓存主要通过 HTTP 响应头中的 <strong>Expires</strong> 和 <strong>Cache-Control</strong> 属性来实现。这些属性是由服务器在响应中设置的，并指示浏览器如何缓存资源。</p> <p>expires记录有效时间，cache-control除了记录相对有效时间（xx秒）外，还可以记录其它信息（no-cache,no-store），cache-control的优先级更高</p> <h3 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h3> <p><strong>概念</strong>
协商缓存需要客户端和服务器之间的交互。当缓存资源过期时，客户端会向服务器发送请求，服务器根据请求头中的信息判断客户端缓存的资源是否仍然有效。命中返回304</p> <p><strong>好处</strong>
节省带宽：对于未修改的资源，服务器只返回状态码而不发送资源内容，节省了带宽。
减少延迟：即使需要与服务器通信，304 响应也比完全下载新的资源更快。
保持资源最新：确保浏览器使用的是最新版本的资源，提高了数据的一致性和可靠性。
平衡性能与新鲜度：在减少不必要请求的同时，确保资源的实时更新。
<strong>如何开启</strong>
协商缓存使用的主要属性是服务器返回的 <strong>Last-Modified 和 ETag</strong>，而在下次请求时会使用 If-Modified-Since 和 If-None-Match，它们的值在实现协商缓存时起着关键作用。</p> <h2 id="跨域时如何处理cookie"><a href="#跨域时如何处理cookie" class="header-anchor">#</a> 跨域时如何处理cookie</h2> <p>首先，在<strong>服务端</strong>设置响应头：</p> <p><strong>Access-Control-Allow-Credentials: true</strong>（将“允许跨域请求携带认证信息”的值设为true）</p> <p><strong>Access-Control-Allow-Origin</strong>: 请求域名（配置允许访问的域名）</p> <p>接着，在客户端也要设置 <strong>withCredential</strong>s 使其允许 Cookie 共享，就可以实现 Cookie 的跨域访问了。</p> <h2 id="iframe的缺点-弊端"><a href="#iframe的缺点-弊端" class="header-anchor">#</a> iframe的缺点，弊端</h2> <p>1、加载速度慢，由于iframe需要加载嵌入的网页，因此会增加整体页面的加载时间；</p> <p>2、对搜索引擎不友好，搜索引擎通常会忽略iframe中的内容，这意味着嵌入的网页的内容不会被搜索引擎索引；</p> <p>3、安全性问题，恶意网站可以通过iframe来进行钓鱼、点击劫持等攻击，从而危害用户的隐私和安全；</p> <p>4、兼容性问题，不同浏览器对iframe的支持程度不同等等。</p> <p>总结：加载速度，SEO，网络安全，兼容性</p> <h2 id="sessionstorage、localstorage、cookies、session的区别"><a href="#sessionstorage、localstorage、cookies、session的区别" class="header-anchor">#</a> SessionStorage、LocalStorage、Cookies、Session的区别</h2> <h3 id="作用域的区别"><a href="#作用域的区别" class="header-anchor">#</a> 作用域的区别</h3> <p>SessionStorage仅在当前会话期间有效，作用于窗口或标签页，不同窗口的SessionStorage不同</p> <p>但是！！SessionStorage*<em>在该标签或窗口打开一个新页面时会复制顶级浏览会话的上下文作为新会话的上文，也就是说A窗口有SessionStorage数据并且从A窗口通过window.open()或a标签跳转新页面时，会将A窗口的SessionStorage*<u>复制</u><em>一份过去，但不是共享</em></em></p> <p>LocalStorage和Cookies作用于同一个域（协议、域名、端口），同一个域读取出相同的内容</p> <p>Session也是会话级别</p> <p>会话：用户打开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程为一个会话。</p> <h3 id="作用时间的区别"><a href="#作用时间的区别" class="header-anchor">#</a> 作用时间的区别</h3> <p>SessionStorage只存在于当前窗口的活跃时间，窗口关闭则消失（Session同）</p> <p>LocalStorage存放在浏览器内存中且不删除则长期存在</p> <p>Cookies默认同SessionStorage，与窗口同时存在，但是可以通过expires或max-age设置过期的时间，过期自动清除</p> <h3 id="存储位置的区别"><a href="#存储位置的区别" class="header-anchor">#</a> 存储位置的区别</h3> <p>Session是存储在服务器端的，其它都是客户端浏览器</p> <h3 id="传输数据"><a href="#传输数据" class="header-anchor">#</a> 传输数据</h3> <p>Cookie：每次请求都会携带 Cookie 数据，影响性能。
Session：仅在初始会话时传输 Session ID，后续请求不再携带全部会话数据。（当cookie被禁用时，可以使用url重写技术来传递sessionId）
LocalStorage：不随请求发送，仅在客户端存储和访问。
SessionStorage：不随请求发送，仅在客户端存储和访问。</p> <h2 id="localstorage和indexeddb"><a href="#localstorage和indexeddb" class="header-anchor">#</a> LocalStorage和indexedDB</h2> <h3 id="同"><a href="#同" class="header-anchor">#</a> 同</h3> <p>遵守同源策略，不同域的存储资源不共享</p> <h3 id="异"><a href="#异" class="header-anchor">#</a> 异</h3> <p>LocalStorage存储空间限制：5MB-10MB</p> <p>indexedDB存储空间限制：本地磁盘剩余空间的50%，也会由不同浏览器限制而不同。</p> <h3 id="indexeddb"><a href="#indexeddb" class="header-anchor">#</a> indexedDB</h3> <ol><li><strong>键值型数据库</strong></li> <li>面向Javascript对象，允许存储复杂的结构体对象</li> <li>异步API，通常不是返回数据而是callback</li> <li>自带transition事务，所有操作都会绑定特殊的事务上</li></ol> <h2 id="spa"><a href="#spa" class="header-anchor">#</a> SPA</h2> <h3 id="概念"><a href="#概念" class="header-anchor">#</a> 概念</h3> <p>SPA是一种特殊的web应用。将<strong>所有的活动局限于一个Web页面</strong>中，仅在该Web页面初始化时加载相应的HTML、JavaScript和CSS。 一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转。取而代之的是利用JavaScript动态的变换HTML的内容， 从而实现UI与用户的交互。</p> <h3 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h3> <ol><li><p>具有良好的交互体验
因为是局部渲染，每个部分是单独的模块，避免了不必要的跳转和重复渲染。</p></li> <li><p>前后端分离，架构清晰</p></li></ol> <h3 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h3> <ol><li><p><strong>可能出现首屏加载时间过长</strong></p> <p>因为SPA是将所有的活动局限于一个Web页面，需要在加载页面的时候将HTML、JavaScript和CSS统一加载，部分页面可以在需要的时候加载。这样会导致初次加载耗时多，可能出现首屏加载时间过长问题。</p></li> <li><p><strong>不利于SEO（搜索引擎优化）</strong></p> <p>由于所有的内容都在一个页面中进行动态的替换，利用hash片段实现路由，而利用hash片段不会作为HTTP请求中的一部分发送给服务器，所以在SEO上存在弱势。</p></li> <li><p>导航不能用(现在有history模式，可以用)</p> <p>由于单页Web应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，如果需要导航，需要自行设置前进后退。</p></li></ol> <h3 id="解决首屏加载慢问题"><a href="#解决首屏加载慢问题" class="header-anchor">#</a> 解决首屏加载慢问题</h3> <p><img src="/fffBlog/assets/img/white.33157354.png" alt="img"></p> <h2 id="浏览器内核"><a href="#浏览器内核" class="header-anchor">#</a> 浏览器内核</h2> <p>浏览器内核主要分为两部分：渲染引擎和js引擎。</p> <h3 id="渲染引擎"><a href="#渲染引擎" class="header-anchor">#</a> 渲染引擎</h3> <p>负责加载处理HTML,CSS构建DOM树，CSSOM树并结合组成渲染树，计算网页显示方式，组织页面元素回流重绘，渲染网页呈现到浏览器上来。</p> <h3 id="js引擎"><a href="#js引擎" class="header-anchor">#</a> js引擎</h3> <p>解析和执行javascript脚本来实现网页的动态效果。</p> <p><strong>不同内核对对网页的语法解释不同，所以渲染效果也可能不相同。</strong></p> <h3 id="常见内核"><a href="#常见内核" class="header-anchor">#</a> 常见内核</h3> <p>Trident:三叉戟内核，用于IE</p> <p>Webkit:源码结构清晰，渲染速度极快，用于Safari,Chrome(早期)</p> <p>Blink:在Webkit基础上修改优化,Chrome,Edge</p> <p>Gecko:用于FireFox</p> <h2 id="前端监控"><a href="#前端监控" class="header-anchor">#</a> 前端监控</h2> <h3 id="捕获网络异常错误"><a href="#捕获网络异常错误" class="header-anchor">#</a> 捕获网络异常错误</h3> <p>监听error事件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//网络请求异常不会冒泡，必须设置在捕获阶段触发</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'捕获'</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// 这里只有捕获才能触发事件，冒泡是不能触发</span>
</code></pre></div><h3 id="捕获未处理的promise错误"><a href="#捕获未处理的promise错误" class="header-anchor">#</a> 捕获未处理的Promise错误</h3> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'unhandledrejection'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'捕获为处理的Promise错误'</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span> 
</code></pre></div><h3 id="捕获js同步错误"><a href="#捕获js同步错误" class="header-anchor">#</a> 捕获JS同步错误</h3> <p>window.onerror</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">message<span class="token punctuation">,</span> source<span class="token punctuation">,</span> lineno<span class="token punctuation">,</span> colno<span class="token punctuation">,</span> error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'捕获到异常：'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>message<span class="token punctuation">,</span> source<span class="token punctuation">,</span> lineno<span class="token punctuation">,</span> colno<span class="token punctuation">,</span> error<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="前端性能指标"><a href="#前端性能指标" class="header-anchor">#</a> 前端性能指标</h2> <ol><li>LCP(Largest Contentful Paint)最大内容绘制</li> <li>INP(Interaction to Next Paint)下一次交互的绘制</li> <li>CLS(Cumulative Layout Shift)累计布局偏移</li> <li>TTFB(Time to First Byte)首字节加载时间</li> <li>FCP(First Contentful Paint)首屏加载时间</li></ol> <h2 id="前端预加载"><a href="#前端预加载" class="header-anchor">#</a> 前端预加载</h2> <h3 id="概念-2"><a href="#概念-2" class="header-anchor">#</a> 概念</h3> <p>在确认用户会使用/浏览到某个资源时，提前对该静态资源进行加载，提高首屏加载速度，减少屏幕闪白的频率，优化用户体验</p> <h3 id="实现"><a href="#实现" class="header-anchor">#</a> 实现</h3> <p>1.prefetch</p> <p>利用浏览器<strong>空闲时间加载</strong>资源并将其存储在缓存中，使用时在缓存获取
</p><head><link rel="prefetch" href="static/img/ticket_bg.a5bb7c33.png"> <link rel="subresource" href="styles.css"></head><p></p> <p>2.preload</p> <p>声明当前页面的关键资源，<strong>强制</strong>浏览器<strong>尽快</strong>加载</p> <head><link rel="preload" as="font" href="&lt;%= require('/assets/fonts/AvenirNextLTPro-Demi.otf') %&gt;" crossorigin=""> <link rel="preload" as="font" href="&lt;%= require('/assets/fonts/AvenirNextLTPro-Regular.otf') %&gt;" crossorigin=""></head> <p>3.WebPack插件<strong>preload-webpack-plugin</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>
  <span class="token keyword">new</span> <span class="token class-name">PreloadWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">rel</span><span class="token operator">:</span> <span class="token string">'preload'</span>，
    <span class="token keyword">as</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//资源类型</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">'style'</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.woff$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">'font'</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.png$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">'image'</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token string">'script'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">include</span><span class="token operator">:</span> <span class="token string">'asyncChunks'</span><span class="token punctuation">,</span> <span class="token comment">// preload模块范围，还可取值'initial'|'allChunks'|'allAssets',</span>
    <span class="token literal-property property">fileBlacklist</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.svg</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">]</span> <span class="token comment">// 资源黑名单</span>
    <span class="token literal-property property">fileWhitelist</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.script</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">]</span> <span class="token comment">// 资源白名单</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span>
</code></pre></div><p>4.对WebPack异步加载的模块使用注释标记</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackPreload: true */</span> <span class="token string">'AsyncModule'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>5.DNS预解析</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>link rel<span class="token operator">=</span><span class="token string">&quot;dns-prefetch&quot;</span> href<span class="token operator">=</span><span class="token string">&quot;//example.com&quot;</span><span class="token operator">&gt;</span>
</code></pre></div><p>6.图像预加载</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>image.png<span class="token punctuation">&quot;</span></span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token value css language-css"><span class="token property">display</span><span class="token punctuation">:</span>none</span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;./imagePreload.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token comment">// imagePreload.js文件</span>
<span class="token keyword">var</span> image<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
image<span class="token punctuation">.</span>src<span class="token operator">=</span><span class="token string">&quot;https://xxx.xx.com/image.jpg&quot;</span><span class="token punctuation">;</span><span class="token comment">//提前加载图片</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/fffBlog/assets/js/app.cec7b3d6.js" defer></script><script src="/fffBlog/assets/js/2.92b40a62.js" defer></script><script src="/fffBlog/assets/js/1.40f520a9.js" defer></script><script src="/fffBlog/assets/js/16.9e0b3e50.js" defer></script>
  </body>
</html>
