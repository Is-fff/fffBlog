<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Hooks是什么 | 吴炫境个人博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="代码学习记录">
    
    <link rel="preload" href="/fffBlog/assets/css/0.styles.a74e95d9.css" as="style"><link rel="preload" href="/fffBlog/assets/js/app.cec7b3d6.js" as="script"><link rel="preload" href="/fffBlog/assets/js/2.92b40a62.js" as="script"><link rel="preload" href="/fffBlog/assets/js/1.40f520a9.js" as="script"><link rel="preload" href="/fffBlog/assets/js/35.e356d625.js" as="script"><link rel="prefetch" href="/fffBlog/assets/js/10.0c61e136.js"><link rel="prefetch" href="/fffBlog/assets/js/11.2c20532d.js"><link rel="prefetch" href="/fffBlog/assets/js/12.c582b446.js"><link rel="prefetch" href="/fffBlog/assets/js/13.207a685b.js"><link rel="prefetch" href="/fffBlog/assets/js/14.1fdf4a2a.js"><link rel="prefetch" href="/fffBlog/assets/js/15.9fb4f1ad.js"><link rel="prefetch" href="/fffBlog/assets/js/16.9e0b3e50.js"><link rel="prefetch" href="/fffBlog/assets/js/17.aba044a2.js"><link rel="prefetch" href="/fffBlog/assets/js/18.beba6154.js"><link rel="prefetch" href="/fffBlog/assets/js/19.fe18b34a.js"><link rel="prefetch" href="/fffBlog/assets/js/20.d016de69.js"><link rel="prefetch" href="/fffBlog/assets/js/21.bedebcf0.js"><link rel="prefetch" href="/fffBlog/assets/js/22.0942125b.js"><link rel="prefetch" href="/fffBlog/assets/js/23.2b2a8dca.js"><link rel="prefetch" href="/fffBlog/assets/js/24.b8a35182.js"><link rel="prefetch" href="/fffBlog/assets/js/25.f57de6ea.js"><link rel="prefetch" href="/fffBlog/assets/js/26.d9494331.js"><link rel="prefetch" href="/fffBlog/assets/js/27.db387258.js"><link rel="prefetch" href="/fffBlog/assets/js/28.ca541479.js"><link rel="prefetch" href="/fffBlog/assets/js/29.70adba3c.js"><link rel="prefetch" href="/fffBlog/assets/js/3.182c257f.js"><link rel="prefetch" href="/fffBlog/assets/js/30.02c8b825.js"><link rel="prefetch" href="/fffBlog/assets/js/31.1ccc7f5f.js"><link rel="prefetch" href="/fffBlog/assets/js/32.79b32ca7.js"><link rel="prefetch" href="/fffBlog/assets/js/33.e45d1bf9.js"><link rel="prefetch" href="/fffBlog/assets/js/34.58b6d383.js"><link rel="prefetch" href="/fffBlog/assets/js/36.795ee075.js"><link rel="prefetch" href="/fffBlog/assets/js/37.bb6c6325.js"><link rel="prefetch" href="/fffBlog/assets/js/4.a29c46b6.js"><link rel="prefetch" href="/fffBlog/assets/js/5.e6661a5c.js"><link rel="prefetch" href="/fffBlog/assets/js/6.4c5bfda8.js"><link rel="prefetch" href="/fffBlog/assets/js/7.f22cdc7f.js"><link rel="prefetch" href="/fffBlog/assets/js/vendors~docsearch.11055bee.js">
    <link rel="stylesheet" href="/fffBlog/assets/css/0.styles.a74e95d9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/fffBlog/" class="home-link router-link-active"><!----> <span class="site-name">吴炫境个人博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/fffBlog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端基础" class="dropdown-title"><span class="title">前端基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端基础" class="mobile-dropdown-title"><span class="title">前端基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/html.html" class="nav-link">
  HTML5
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/Js.html" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/css.html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/ES6.html" class="nav-link">
  ES6新特性
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/ts.html" class="nav-link">
  TypeScript
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/something.html" class="nav-link">
  杂记
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端框架" class="dropdown-title"><span class="title">前端框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端框架" class="mobile-dropdown-title"><span class="title">前端框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fffBlog/FrameworkPage/index.html" class="nav-link">
  框架概述
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/FrameworkPage/vue.html" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/FrameworkPage/react.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  React
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="构建工具" class="dropdown-title"><span class="title">构建工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="构建工具" class="mobile-dropdown-title"><span class="title">构建工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fffBlog/toolPage/webpack.html" class="nav-link">
  webpack
</a></li></ul></div></div><div class="nav-item"><a href="/fffBlog/browserPage/browser.html" class="nav-link">
  浏览器相关
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机系统" class="dropdown-title"><span class="title">计算机系统</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机系统" class="mobile-dropdown-title"><span class="title">计算机系统</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fffBlog/CNTPage/cnt.html" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/CNTPage/algorithm.html" class="nav-link">
  算法
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/CNTPage/dataStructure.html" class="nav-link">
  数据结构
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/fffBlog/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端基础" class="dropdown-title"><span class="title">前端基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端基础" class="mobile-dropdown-title"><span class="title">前端基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/html.html" class="nav-link">
  HTML5
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/Js.html" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/css.html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/ES6.html" class="nav-link">
  ES6新特性
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/ts.html" class="nav-link">
  TypeScript
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/BasisPage/something.html" class="nav-link">
  杂记
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端框架" class="dropdown-title"><span class="title">前端框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端框架" class="mobile-dropdown-title"><span class="title">前端框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fffBlog/FrameworkPage/index.html" class="nav-link">
  框架概述
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/FrameworkPage/vue.html" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/FrameworkPage/react.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  React
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="构建工具" class="dropdown-title"><span class="title">构建工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="构建工具" class="mobile-dropdown-title"><span class="title">构建工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fffBlog/toolPage/webpack.html" class="nav-link">
  webpack
</a></li></ul></div></div><div class="nav-item"><a href="/fffBlog/browserPage/browser.html" class="nav-link">
  浏览器相关
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机系统" class="dropdown-title"><span class="title">计算机系统</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机系统" class="mobile-dropdown-title"><span class="title">计算机系统</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fffBlog/CNTPage/cnt.html" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/CNTPage/algorithm.html" class="nav-link">
  算法
</a></li><li class="dropdown-item"><!----> <a href="/fffBlog/CNTPage/dataStructure.html" class="nav-link">
  数据结构
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Hooks是什么</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fffBlog/FrameworkPage/react.html#hooks是什么" class="sidebar-link">Hooks是什么</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fffBlog/FrameworkPage/react.html#react常用钩子" class="sidebar-link">React常用钩子</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#usestate" class="sidebar-link">useState</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#useeffect" class="sidebar-link">useEffect</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#useref" class="sidebar-link">useRef</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#usememo" class="sidebar-link">useMemo</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#usecallback" class="sidebar-link">useCallback</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#usecontext" class="sidebar-link">useContext</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#usereducer" class="sidebar-link">useReducer</a></li></ul></li><li><a href="/fffBlog/FrameworkPage/react.html#多层级组件设计思路" class="sidebar-link">多层级组件设计思路</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#组件ui层面" class="sidebar-link">组件UI层面</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#代码逻辑层面" class="sidebar-link">代码逻辑层面</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#useref细节" class="sidebar-link">useRef细节</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#应用场景" class="sidebar-link">应用场景</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#优化重复的网络请求" class="sidebar-link">优化重复的网络请求</a></li></ul></li><li><a href="/fffBlog/FrameworkPage/react.html#react18更新内容-新特性" class="sidebar-link">React18更新内容/新特性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#并发渲染" class="sidebar-link">并发渲染</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#自动批处理" class="sidebar-link">自动批处理</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#过渡更新-实现并发渲染" class="sidebar-link">过渡更新（实现并发渲染）</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#新的suspence特性" class="sidebar-link">新的Suspence特性</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#新的渲染api" class="sidebar-link">新的渲染API</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#新的严格模式" class="sidebar-link">新的严格模式</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#新的hook" class="sidebar-link">新的Hook</a></li></ul></li><li><a href="/fffBlog/FrameworkPage/react.html#react如何引入css" class="sidebar-link">React如何引入CSS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#使用行内样式" class="sidebar-link">使用行内样式</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#引入css文件" class="sidebar-link">引入CSS文件</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#css-module" class="sidebar-link">CSS Module</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#css-in-js" class="sidebar-link">CSS in JS</a></li></ul></li><li><a href="/fffBlog/FrameworkPage/react.html#react生命周期" class="sidebar-link">React生命周期</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#react17之前-旧版生命周期" class="sidebar-link">React17之前，旧版生命周期</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#react17之后-新版生命周期" class="sidebar-link">React17之后，新版生命周期</a></li></ul></li><li><a href="/fffBlog/FrameworkPage/react.html#父子组件生命周期执行顺序" class="sidebar-link">父子组件生命周期执行顺序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#父子组件初始化" class="sidebar-link">父子组件初始化</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#子组件修改自身state" class="sidebar-link">子组件修改自身state</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#父组件修改props" class="sidebar-link">父组件修改props</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#卸载子组件" class="sidebar-link">卸载子组件</a></li></ul></li><li><a href="/fffBlog/FrameworkPage/react.html#react的异常处理" class="sidebar-link">React的异常处理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fffBlog/FrameworkPage/react.html#setstate的同步和异步" class="sidebar-link">setState的同步和异步</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#在react18之前" class="sidebar-link">在React18之前</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#在react18之后" class="sidebar-link">在React18之后</a></li></ul></li><li><a href="/fffBlog/FrameworkPage/react.html#react的fiber架构" class="sidebar-link">React的Fiber架构</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fffBlog/FrameworkPage/react.html#react的diff算法" class="sidebar-link">React的Diff算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#tree层" class="sidebar-link">Tree层</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#component层" class="sidebar-link">Component层</a></li><li class="sidebar-sub-header"><a href="/fffBlog/FrameworkPage/react.html#element层" class="sidebar-link">Element层</a></li></ul></li><li><a href="/fffBlog/FrameworkPage/react.html#react组件过渡动画" class="sidebar-link">React组件过渡动画</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fffBlog/FrameworkPage/react.html#为什么使用函数式组件-优点" class="sidebar-link">为什么使用函数式组件，优点</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fffBlog/FrameworkPage/react.html#react-hooks-不能在循环条件嵌套语句中使用的原因" class="sidebar-link">React Hooks 不能在循环条件嵌套语句中使用的原因</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="hooks是什么"><a href="#hooks是什么" class="header-anchor">#</a> Hooks是什么</h2> <p>Hooks 是 React 16.8 版本引入的一项特性，它<strong>允许在函数式组件中使用状态和其他 React 特性</strong>，而不需要使用类组件。Hooks 就是钩子，作用是把某个目标结果钩到某个可能会变化的数据源或者事件源上，那么当被钩到的数据或事件发生变化时，产生这个目标结果的代码会重新执行，产生更新后的结果。</p> <h2 id="react常用钩子"><a href="#react常用钩子" class="header-anchor">#</a> React常用钩子</h2> <h3 id="usestate"><a href="#usestate" class="header-anchor">#</a> useState</h3> <p>控制响应式状态</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span>setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="useeffect"><a href="#useeffect" class="header-anchor">#</a> useEffect</h3> <p>副作用函数，用于执行React执行时的副作用操作(发起网络请求，启动定时器，手动修改DOM)</p> <p>一般用来实现，组件的生命周期，组件的监视属性</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">useEffect</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span><span class="token punctuation">[</span>dependArray<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//callback,每次执行时的回调，可以返回一个函数，该函数会在组件卸载前执行（实现componentWillUnmount）</span>
<span class="token comment">//dependArray依赖数组</span>
<span class="token comment">//不写dependArray,监测所有state,其中一个变化就会触发函数</span>
<span class="token comment">//dependArray = [],谁也不监测,但会在组件挂载完成之后执行一次（实现componentMounted）</span>
</code></pre></div><h3 id="useref"><a href="#useref" class="header-anchor">#</a> useRef</h3> <p>用于创建一个对象用于保存和访问可变的ref对象</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> myButton <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化为null</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myButtom<span class="token punctuation">.</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//目标dom</span>
</code></pre></div><h3 id="usememo"><a href="#usememo" class="header-anchor">#</a> useMemo</h3> <p>用于缓存和重用计算成本高的值，用于提升性能，类似于watch监视属性(实现shouldComponentUpdate)</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">comuteData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//size改变才会更新result</span>
</code></pre></div><h3 id="usecallback"><a href="#usecallback" class="header-anchor">#</a> useCallback</h3> <p>类似于useMemo，不过useCallback是用来缓存回调函数的，以便在依赖项变化时避免不必要的函数重新创建</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">const</span> handleClick <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    	<span class="token comment">// 处理点击事件逻辑</span>
          <span class="token function">setCount</span><span class="token punctuation">(</span>count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token comment">//由于useCallback返回的是一个函数，因此，你甚至可以用它来返回一个子函数组件</span>
  <span class="token comment">//优点：可以避免父组件每次更新时都重新渲染这个组件</span>
</code></pre></div><h3 id="usecontext"><a href="#usecontext" class="header-anchor">#</a> useContext</h3> <p>创建状态上下文，用于在多层嵌套的组件中传递数据</p> <h3 id="usereducer"><a href="#usereducer" class="header-anchor">#</a> useReducer</h3> <p><code>useReducer</code> 是 <code>useState</code> 的替代方案。它接收一个形如 <code>(state, action) =&gt; newState 的 reducer</code>，并返回当前的 state 以及与其配套的 <code>dispatch</code> 方法。</p> <p>当状态更新逻辑较复杂时可以考虑使用 useReducer。useReducer 可以同时更新多个状态，而且能把对状态的修改从组件中独立出来。</p> <p>相比于 useState，useReducer 可以更好的描述“如何更新状态”。例如：组件负责发出行为，useReducer 负责更新状态。</p> <p>好处是：<strong>让代码逻辑更清晰，代码行为更易预测。</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> initState<span class="token punctuation">,</span> initAction<span class="token operator">?</span><span class="token punctuation">)</span><span class="token comment">//initAction:state初始化处理函数</span>
<span class="token keyword">const</span> <span class="token function-variable function">reducer</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'count'</span><span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token operator">...</span>state<span class="token punctuation">,</span> <span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">return</span> state
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>useState<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>                                 
<span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span>count<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment">//修改状态</span>
</code></pre></div><h2 id="多层级组件设计思路"><a href="#多层级组件设计思路" class="header-anchor">#</a> 多层级组件设计思路</h2> <p><strong>需求</strong>：改善多层props传递时导致的一些中间组件无意义重渲染</p> <h3 id="组件ui层面"><a href="#组件ui层面" class="header-anchor">#</a> 组件UI层面</h3> <p>使用Context定义上下文/状态管理工具</p> <h3 id="代码逻辑层面"><a href="#代码逻辑层面" class="header-anchor">#</a> 代码逻辑层面</h3> <ol><li><strong>组件职责单一</strong>：确保每个组件专注于单一功能，减少组件间状态依赖依赖。</li> <li><strong>状态提升</strong>：将低级组件依赖的状态提升到高级组件，中间组件只协助传递不使用。</li> <li><strong>自定义 Hooks</strong>：封装复杂的逻辑，便于复用。</li> <li><strong>按功能划分组件</strong>：模块化功能，提高代码可维护性。</li> <li><strong>性能优化</strong>：使用 <code>React.memo</code> 和 <code>useCallback</code> 避免不必要的重新渲染。</li></ol> <h3 id="useref细节"><a href="#useref细节" class="header-anchor">#</a> useRef细节</h3> <p>useRef 返回一个可变的 ref 对象，其内部只有一个 current 属性被初始化为传入的参数（initialValue）
<strong>useRef 返回的 ref 对象在组件的整个生命周期内持续存在</strong> <strong>更新 current 值时并不会触发页面的重新渲染（re-render）</strong>
useRef 会在每次渲染时返回同一个 ref 对象
本质上，useRef 就像是可以在其 .current 属性中保存一个可变值的“盒子”。</p> <p>因此，Ref不仅可以用来存放元素ref，还可以用来跨渲染周期保存对象。</p> <h3 id="应用场景"><a href="#应用场景" class="header-anchor">#</a> 应用场景</h3> <p><strong>实现useEffect的对象监听</strong></p> <p>使用useRef保存上一次渲染周期的监听对象，和当前对象深对比，实现useEffecr监听对象</p> <p>（useEffect监视对象引用时会无限触发，因为每一次渲染都会重新创建对象，每次的引用都不同）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> isEqual <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lodash'</span><span class="token punctuation">;</span><span class="token comment">//使用lodash库的深比较</span>
<span class="token keyword">const</span> <span class="token function-variable function">useCampare</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">value</span><span class="token operator">:</span> any<span class="token punctuation">,</span> <span class="token literal-property property">compare</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> useRef<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compare</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> ref<span class="token punctuation">.</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// deep compare</span>
    ref<span class="token punctuation">.</span>current <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> ref<span class="token punctuation">.</span>current<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> compareObject <span class="token operator">=</span> <span class="token function">useCampare</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> isEqual<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>compareObject<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="优化重复的网络请求"><a href="#优化重复的网络请求" class="header-anchor">#</a> 优化重复的网络请求</h3> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token keyword">const</span> <span class="token punctuation">[</span>data<span class="token punctuation">,</span> setData<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> hasFetched <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用于跟踪请求是否已经发出过，或者跟踪请求参数是否改变</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hasFetched<span class="token punctuation">.</span>current<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 如果请求已发出，则不再发出新的请求</span>

    <span class="token keyword">const</span> <span class="token function-variable function">fetchData</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'https://api.example.com/data'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setData</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        hasFetched<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 标记请求已发出</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'请求失败'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="react18更新内容-新特性"><a href="#react18更新内容-新特性" class="header-anchor">#</a> React18更新内容/新特性</h2> <h3 id="并发渲染"><a href="#并发渲染" class="header-anchor">#</a> 并发渲染</h3> <p>新的底层渲染机制，使得React能够同时准备多个版本的UI。</p> <p>在18之前，采用同步渲染，即一旦渲染无法中断，直到用户看到渲染结果。</p> <p>而并发渲染的关键特性：<strong>渲染可中断</strong>，随时可以开启，挂起，继续一个渲染任务。这样做，React 就可以在后台提前准备新的屏幕内容，而不阻塞主线程。这意味着用户输入可以被立即响应，即使存在大量渲染任务，也能有流畅的用户体验。</p> <h3 id="自动批处理"><a href="#自动批处理" class="header-anchor">#</a> 自动批处理</h3> <p>在React18之前，自动批处理只存在于<strong>合成事件</strong>处理程序中，即点击事件之后触发的<strong>回调中有多个setState动作，只会触发一次渲染</strong></p> <p>But，在Promise和setTimeout定时器中，默认不会开启这样的机制</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 以前: 只有 React 事件会被批处理。</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token parameter">c</span> <span class="token operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token parameter">f</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// React 会渲染两次，每次更新一个状态（没有批处理）</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 现在: 超时，promise，本机事件处理程序</span>
<span class="token comment">// 原生应用时间处理程序或者任何其他时间都被批处理了</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token parameter">c</span> <span class="token operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token parameter">f</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 最终，React 将仅会重新渲染一次（这就是批处理！）</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="过渡更新-实现并发渲染"><a href="#过渡更新-实现并发渲染" class="header-anchor">#</a> 过渡更新（实现并发渲染）</h3> <ul><li><code>useTransition</code>： 一个用于开启过渡更新的 Hook，用于跟踪待定转场状态。</li> <li><code>startTransition</code>： 当 Hook 不能使用时，用于开启过渡的方法。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> startTransition <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token comment">// 紧急更新: 显示输入的内容</span>
<span class="token function">setInputValue</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 将任何内部的状态更新都标记为过渡更新</span>
<span class="token function">startTransition</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 过渡更新: 展示结果</span>
  <span class="token function">setSearchQuery</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="新的suspence特性"><a href="#新的suspence特性" class="header-anchor">#</a> 新的Suspence特性</h3> <p>支持服务端 Suspense，并且使用并发渲染特性扩展了其功能。</p> <h3 id="新的渲染api"><a href="#新的渲染api" class="header-anchor">#</a> 新的渲染API</h3> <h3 id="新的严格模式"><a href="#新的严格模式" class="header-anchor">#</a> 新的严格模式</h3> <p>React 18 为严格模式下的开发环境引入了一个新的检查机制。每当组件第一次挂载时，这个检查机制将自动卸载又重新挂载每个组件，并在第二次挂载时复用先前的状态。</p> <p>这<strong>允许 React 在保留状态的同时添加和移除 UI。</strong></p> <h3 id="新的hook"><a href="#新的hook" class="header-anchor">#</a> 新的Hook</h3> <p>useId,useTransition,useDeferredValue,useSyncExternalStore,useInsertionEffect</p> <h2 id="react如何引入css"><a href="#react如何引入css" class="header-anchor">#</a> React如何引入CSS</h2> <h3 id="使用行内样式"><a href="#使用行内样式" class="header-anchor">#</a> 使用行内样式</h3> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">//驼峰命名法</span>
<span class="token keyword">const</span> div1 <span class="token operator">=</span> <span class="token punctuation">{</span>
 <span class="token literal-property property">width</span><span class="token operator">:</span> <span class="token string">&quot;300px&quot;</span><span class="token punctuation">,</span>
 <span class="token literal-property property">margin</span><span class="token operator">:</span> <span class="token string">&quot;30px auto&quot;</span><span class="token punctuation">,</span>
 <span class="token literal-property property">backgroundColor</span><span class="token operator">:</span> <span class="token string">&quot;#44014C&quot;</span><span class="token punctuation">,</span> 
 <span class="token literal-property property">minHeight</span><span class="token operator">:</span> <span class="token string">&quot;200px&quot;</span><span class="token punctuation">,</span>
 <span class="token literal-property property">boxSizing</span><span class="token operator">:</span> <span class="token string">&quot;border-box&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>优点：样式隔离，不会污染其它组件</p> <p>缺点：JS代码样式冗杂混乱，代码提示不友好，某些样式无法编写（伪类/为元素）</p> <h3 id="引入css文件"><a href="#引入css文件" class="header-anchor">#</a> 引入CSS文件</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token string">'./App.css'</span><span class="token punctuation">;</span>
</code></pre></div><p>优点：学习成本低，CSS友好</p> <p>缺点：样式全局生效，互相影响</p> <h3 id="css-module"><a href="#css-module" class="header-anchor">#</a> CSS Module</h3> <p>采用WebPack特性的方案，需要在WebPack配置modules:true</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token string">'./App.module.css'</span><span class="token punctuation">;</span>
</code></pre></div><p>优点：局部化样式(更好的模块化)，解决命名冲突，学习成本低，预处理器支持（SCSS/Less）</p> <p>缺点：依赖Webpack,样式嵌套受限</p> <h3 id="css-in-js"><a href="#css-in-js" class="header-anchor">#</a> CSS in JS</h3> <p>第三方库提供，如styled-components</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> SelfLink <span class="token operator">=</span> styled<span class="token punctuation">.</span>div<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
 height: 50px;
 border: 1px solid red;
 color: yellow;
</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
</code></pre></div><p>优点：样式和组件紧耦合易于维护，支持动态样式（JS支持），样式隔离，易于组合</p> <p>缺点：有一定的学习成本，增加JS负担，打包的bundle.js会更大，不利于调试</p> <h2 id="react生命周期"><a href="#react生命周期" class="header-anchor">#</a> React生命周期</h2> <h3 id="react17之前-旧版生命周期"><a href="#react17之前-旧版生命周期" class="header-anchor">#</a> React17之前，旧版生命周期</h3> <p><img src="img/ReactLifeOld.png" alt="img"></p> <p>这个版本，还没有Hook，所以只有类组件存在生命周期</p> <p>constructor最先调用，可以初始化state</p> <p>componentWillxxx -&gt; render(渲染到页面)  -&gt; componentDidxxx</p> <p>父组件render，会触发子组件的componentWillReceiveProps</p> <p>shouldComponentUpdate()在更新前调用，拿到新旧state和props，判断是否重新渲染</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//组件是否需要更新，需要返回一个布尔值，返回true则更新，返回flase不更新，这是一个关键点</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'shouldComponentUpdate组件是否应该更新，需要返回布尔值'</span><span class="token punctuation">,</span>nextProps<span class="token punctuation">,</span> nextState<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre></div><p>卸载:componentWillUnmount</p> <h3 id="react17之后-新版生命周期"><a href="#react17之后-新版生命周期" class="header-anchor">#</a> React17之后，新版生命周期</h3> <p>新版在render之后，dom不是立刻挂载，还会经历一个getSnapsshotBeforeUpdate钩子</p> <p><img src="img/ReactLifeNew.png" alt="img"></p> <p>弃用了<code>componentWillMount</code>、<code>componentWillReceiveProps</code>、<code>componentWillUpdate</code>这三个钩子（没有Will钩子了），取而代之的是<code>getDerivedStateFromProps</code>,其实就是把那三个钩子的含义融入到了这一个钩子中</p> <p>新增<code>getSnapshotBeforeUpdate</code>，这里可获取到即将要更新的props和state</p> <p>这个生命周期主要为我们提供了一个可以在组件实例化或 props、state 发生变化后根据 props 修改 state 的一个时机。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span>
</code></pre></div><p>在更新阶段 <strong>render 后挂载到真实 DOM 前进行的操作</strong>，它使得组件能在发生更改之前从 DOM 中捕获一些信息。此组件返回的任何值将作为 componentDidUpdate 的第三个参数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     
    <span class="token keyword">return</span> <span class="token string">&quot;getSnapshotBeforeUpdate&quot;</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span> 
<span class="token comment">// 组件更新成功钩子  </span>
<span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">,</span> snapshot</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>snapshot<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// &quot;getSnapshotBeforeUpdate&quot; </span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="父子组件生命周期执行顺序"><a href="#父子组件生命周期执行顺序" class="header-anchor">#</a> 父子组件生命周期执行顺序</h2> <h3 id="父子组件初始化"><a href="#父子组件初始化" class="header-anchor">#</a> 父子组件初始化</h3> <p>父组件 constructor</p> <p>父组件 getDerivedStateFromProps</p> <p>父组件 render</p> <p>子组件 constructor</p> <p>子组件 getDerivedStateFromProps</p> <p>子组件 render</p> <p>子组件 componentDidMount</p> <p>父组件 componentDidMount</p> <p><strong>总结</strong>：render相当于vue的mounted,React是在render的时候，才会去发现子组件并挂载完子组件再挂载自身</p> <h3 id="子组件修改自身state"><a href="#子组件修改自身state" class="header-anchor">#</a> 子组件修改自身state</h3> <p>子组件 getDerivedStateFromProps</p> <p>子组件 shouldComponentUpdate</p> <p>子组件 render</p> <p>子组件 getSnapShotBeforeUpdate</p> <p>子组件 componentDidUpdate</p> <h3 id="父组件修改props"><a href="#父组件修改props" class="header-anchor">#</a> 父组件修改props</h3> <p>父组件 getDerivedStateFromProps</p> <p>父组件 shouldComponentUpdate</p> <p>父组件 render</p> <p>子组件 getDerivedStateFromProps</p> <p>子组件 shouldComponentUpdate</p> <p>子组件 render</p> <p>子组件 getSnapShotBeforeUpdate</p> <p>父组件 getSnapShotBeforeUpdate</p> <p>子组件 componentDidUpdate</p> <p>父组件 componentDidUpdate</p> <p><strong>总结</strong>：子组件render之后会触发记录快照，紧接父组件也记录快照，才触发子组件更新完毕钩子</p> <h3 id="卸载子组件"><a href="#卸载子组件" class="header-anchor">#</a> 卸载子组件</h3> <p>父组件 getDerivedStateFromProps</p> <p>父组件 shouldComponentUpdate</p> <p>父组件 render</p> <p>父组件 getSnapShotBeforeUpdate</p> <p>子组件 componentWillUnmount</p> <p>父组件 componentDidUpdate</p> <p>**总结：**组件卸载，只会执行componentWillUnmount钩子，但是父组件会执行一次update流程，并在挂载完成前把子组件卸载了</p> <h2 id="react的异常处理"><a href="#react的异常处理" class="header-anchor">#</a> React的异常处理</h2> <p>react16引入了<strong>错误边界</strong>概念，错误边界是一个组件，它可以捕获在组件树中任何位置的javaScript错误同时展示降级UI，而不会渲染哪些发送崩溃的组件树</p> <p>形成错误边界的两个条件</p> <div class="language-js extra-class"><pre class="language-js"><code>使用了<span class="token keyword">static</span> <span class="token function">getDerivedStateFromError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//渲染备用UI</span>
<span class="token function">使用了componentDidCatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//打印错误信息</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code> <span class="token keyword">static</span> <span class="token function">getDerivedStateFromError</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 	<span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">hasError</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//降级UI显示状态</span>
 <span class="token punctuation">}</span>
 <span class="token function">componentDidCatch</span><span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> errorInfo</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 	<span class="token function">logErrorToMyService</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> errorInfo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//错误信息上传服务器</span>
 <span class="token punctuation">}</span>
</code></pre></div><p>在react16之后，会把在渲染期间发生的所有错误都打印到控制台，但是无法捕获：</p> <ol><li>事件处理程序</li> <li>异步代码</li> <li>服务端渲染</li> <li>自身抛出来的错误</li></ol> <h2 id="setstate的同步和异步"><a href="#setstate的同步和异步" class="header-anchor">#</a> setState的同步和异步</h2> <h3 id="在react18之前"><a href="#在react18之前" class="header-anchor">#</a> 在React18之前</h3> <p>只要进入了React的调度流程，那么setState就是异步的，而只要没有进入React的调度流程，那么它将是同步的。</p> <p>非React调度：setTimeout、setInterval、原生dom事件处理程序</p> <h3 id="在react18之后"><a href="#在react18之后" class="header-anchor">#</a> 在React18之后</h3> <p>加入了批处理机制，所有的更新都会自动进行批处理(也就是异步合并)</p> <p><strong>解决</strong>：对setState包裹<strong>flushSync</strong>以恢复同步更新</p> <h2 id="react的fiber架构"><a href="#react的fiber架构" class="header-anchor">#</a> React的Fiber架构</h2> <p>Fiber是React16发布的一种新的虚拟dom结构，用于<strong>支持并发渲染和优化Diff算法</strong></p> <p>是一颗链表树，节点会存放渲染前和当前的State状态，便于恢复渲染之后的状态恢复。</p> <p>原先的树结构递归渲染不支持渲染中断，而采用链表引用的方式使得可以在任何时候中断渲染，都可以拿到当前状态。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//Fiber数据结构</span>
type Fiber <span class="token operator">=</span> <span class="token punctuation">{</span>
 <span class="token comment">//Fiber组件类型,ClassComponent、FuntionComponent</span>
 <span class="token literal-property property">tag</span><span class="token operator">:</span> WorkTag<span class="token punctuation">,</span>
 <span class="token comment">// 节点key</span>
 <span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> string<span class="token punctuation">,</span>
 <span class="token comment">// 节点类型</span>
 <span class="token literal-property property">type</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
 <span class="token comment">// 当前节点组件实例</span>
 <span class="token literal-property property">stateNode</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
 <span class="token comment">// 父节点</span>
 <span class="token keyword">return</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
 <span class="token comment">// 子节点</span>
 <span class="token literal-property property">child</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
 <span class="token comment">// 兄弟节点</span>
 <span class="token literal-property property">sibling</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
 <span class="token operator">...</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Diff算法对比的，其实是新旧的Fiber链表树</p> <p>render阶段开始时，会从rootFiber开始向下递归遍历，对遍历到的节点调用<strong>beginWork</strong>方法，若该节点存在children节点，则继续向下递归，直到没有children，则调用<strong>CompleteWork</strong>处理该节点，处理完该节点，则去遍历该节点的兄弟节点，并执行以上相同的过程。</p> <p>对于以下结构</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      i am
      <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>KaSong<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><img src="img/fiber.png" alt="img"></p> <p>fiber过程</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1.</span> rootFiber beginWork
<span class="token number">2.</span> App Fiber beginWork
<span class="token number">3.</span> div Fiber beginWork
<span class="token number">4.</span> <span class="token string">&quot;i am&quot;</span> Fiber beginWork
<span class="token number">5.</span> <span class="token string">&quot;i am&quot;</span> Fiber completeWork
<span class="token number">6.</span> span Fiber beginWork
<span class="token number">7.</span> span Fiber completeWork
<span class="token number">8.</span> div Fiber completeWork
<span class="token number">9.</span> App Fiber completeWork
<span class="token number">10.</span> rootFiber completeWork
<span class="token comment">//没有Kasong是因为会对单文本节点做其它处理以提高性能，这里不说先</span>
</code></pre></div><p><strong>而diff算法，则发生在beginWork和completeWork中</strong></p> <p>beginWork：创建和标记更新节点</p> <p>completeWork：收集副作用列表</p> <h2 id="react的diff算法"><a href="#react的diff算法" class="header-anchor">#</a> React的Diff算法</h2> <p>分为三个层级的策略：Tree、Component、element</p> <h3 id="tree层"><a href="#tree层" class="header-anchor">#</a> Tree层</h3> <p>仅对比相同层级的节点，不做优化，只做增删操作</p> <h3 id="component层"><a href="#component层" class="header-anchor">#</a> Component层</h3> <p>React认为不同类型的 <a href="https://zhida.zhihu.com/search?q=component&amp;zhida_source=entity&amp;is_preview=1" target="_blank" rel="noopener noreferrer">component<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 是很少存在相似 DOM tree 的机会，因此在component层级，会对比节点的组件类型，如果类型相同，则继续往下diff；如果类型不同，则删除该节点和下面所有节点，创建新节点</p> <h3 id="element层"><a href="#element层" class="header-anchor">#</a> Element层</h3> <p>同级节点，采用key值对比</p> <p>提供三种操作INSERT_MARKUP(插入),MOVE_EXISTING(移动),REMOVE_NODE(删除)</p> <h2 id="react组件过渡动画"><a href="#react组件过渡动画" class="header-anchor">#</a> React组件过渡动画</h2> <p>使用CSSTransition组件实现</p> <p>当有两个组件切换：采用SwitchTransition包裹控制</p> <p>当有多个组件切换：采用TransitionGroup包裹控制</p> <h2 id="为什么使用函数式组件-优点"><a href="#为什么使用函数式组件-优点" class="header-anchor">#</a> 为什么使用函数式组件，优点</h2> <ul><li><strong>简单性：</strong> 函数式组件比类组件更简单，更易于理解。它们没有生命周期方法、状态和this绑定增加的复杂性。</li> <li><strong>性能：</strong> 函数式组件比类组件更高效。它们没有为每次渲染创建新实例的额外开销。而且函数式组件可以使用React Hooks，这使得它们的性能更高。</li> <li><strong>更易于测试：</strong> 函数式组件比类组件更易于测试。因为它们只是普通的JavaScript函数，可以使用像Jest这样的JavaScript测试工具进行测试。</li> <li><strong>更易于重用：</strong> 函数式组件比类组件更易于重用。因为它们只是普通的JavaScript函数，可以在应用程序的不同部分轻松重复使用。</li> <li><strong>更易于理解：</strong> 函数式组件比类组件更易于理解。因为它们只是普通的JavaScript函数，它们的行为更可预测、更易于理解。</li> <li><strong>Hooks：</strong> 函数式组件可以使用React Hooks，在函数式组件中使用状态和其他React功能，而类组件不能。</li></ul> <h2 id="react-hooks-不能在循环条件嵌套语句中使用的原因"><a href="#react-hooks-不能在循环条件嵌套语句中使用的原因" class="header-anchor">#</a> React Hooks 不能在循环条件嵌套语句中使用的原因</h2> <p>这是因为hooks为了在函数组件中引入状态，维护了一个<strong>有序表</strong>。</p> <p>这样每次执行才能保证状态能对应上。函数本身不能保存状态，我们需要额外维护一个有序的表，在执行 setState 之类的 hook 时，将它们保存到这个表里。</p> <p>这要求每次函数组件的 hook 执行的位置相同，数量正确，否则会导致错位，不能拿到预期的状态值。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/fffBlog/assets/js/app.cec7b3d6.js" defer></script><script src="/fffBlog/assets/js/2.92b40a62.js" defer></script><script src="/fffBlog/assets/js/1.40f520a9.js" defer></script><script src="/fffBlog/assets/js/35.e356d625.js" defer></script>
  </body>
</html>
