(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{296:function(t,_,s){t.exports=s.p+"assets/img/tcpReuse.9abf925a.png"},297:function(t,_,s){t.exports=s.p+"assets/img/subSend.f32ab9a6.png"},298:function(t,_,s){t.exports=s.p+"assets/img/httpcode.2dc373fe.png"},299:function(t,_,s){t.exports=s.p+"assets/img/threeConnect.26b2e0ec.png"},322:function(t,_,s){"use strict";s.r(_);var v=s(14),a=Object(v.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"http1-1"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http1-1"}},[t._v("#")]),t._v(" HTTP1.1")]),t._v(" "),_("p",[_("strong",[t._v("keepAlive长连接")])]),t._v(" "),_("p",[t._v("允许一个TCP连接同时发起多个请求，为了解决"),_("strong",[t._v("队头阻塞")]),t._v("，但响应还是需要根据顺序处理返回，因此有一些较耗时的处理会阻塞其它请求")]),t._v(" "),_("h2",{attrs:{id:"http2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http2"}},[t._v("#")]),t._v(" HTTP2")]),t._v(" "),_("h3",{attrs:{id:"多路复用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多路复用"}},[t._v("#")]),t._v(" 多路复用")]),t._v(" "),_("p",[_("img",{attrs:{src:s(296),alt:"img"}})]),t._v(" "),_("p",[t._v("在同一条TCP连接管道中，通过将数据分帧，并且在帧的首部加上特殊标识，可以实现发送多个请求"),_("img",{attrs:{src:s(297),alt:"img"}})]),t._v(" "),_("p",[t._v("在二进制分帧层中， HTTP/2 会将所有传输的信息分割为帧（frame）,并对它们采用二进制格式的编码 ，其中 首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。")]),t._v(" "),_("p",[t._v("TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 "),_("strong",[t._v("TCP 慢启动")]),t._v("。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。")]),t._v(" "),_("p",[_("strong",[t._v("HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接")]),t._v("，让高带宽也能真正的服务于 HTTP 的性能提升。")]),t._v(" "),_("h3",{attrs:{id:"首部压缩"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#首部压缩"}},[t._v("#")]),t._v(" 首部压缩")]),t._v(" "),_("p",[t._v("在 HTTP/1 中，HTTP 请求和响应都是由「状态行、请求 / 响应头部、消息主体」三部分组成。但状态行和头部却没有经过任何压缩，直接以纯文本传输。尤其是每次都要传输 UserAgent、Cookie 这类不会频繁变动的内容，完全是一种浪费。")]),t._v(" "),_("p",[_("strong",[t._v("压缩的原理")]),t._v("。头部压缩需要在支持 HTTP/2 的浏览器和服务端之间。")]),t._v(" "),_("p",[t._v("维护一份相同的静态字典（Static Table），包含常见的头部名称，以及特别常见的头部名称与值的组合；")]),t._v(" "),_("p",[t._v("维护一份相同的动态字典（Dynamic Table），可以动态的添加内容；")]),t._v(" "),_("p",[t._v("只发送差异的数据，对相同的数据采用索引来表示")]),t._v(" "),_("p",[t._v("支持基于静态哈夫曼码表的哈夫曼编码（Huffman Coding）；")]),t._v(" "),_("h3",{attrs:{id:"http2支持服务器推送"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http2支持服务器推送"}},[t._v("#")]),t._v(" HTTP2支持服务器推送")]),t._v(" "),_("p",[t._v("为了改善延迟，HTTP/2引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前。一个服务器经常知道一个页面需要很多附加资源，在它响应浏览器第一个请求的时候，可以开始推送这些资源。这允许服务端去完全充分地利用一个可能空闲的网络，改善页面加载时间。")]),t._v(" "),_("h2",{attrs:{id:"http状态码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http状态码"}},[t._v("#")]),t._v(" HTTP状态码")]),t._v(" "),_("p",[_("img",{attrs:{src:s(298),alt:"img"}})]),t._v(" "),_("p",[t._v("100 请求者应当继续提出请求。")]),t._v(" "),_("p",[t._v("200 请求成功")]),t._v(" "),_("p",[t._v("204 请求成功，但没有结果返回")]),t._v(" "),_("p",[t._v("301 请求网页已移动到新位置（浏览器将新的资源缓存到本地）")]),t._v(" "),_("p",[t._v("302 临时重定向（token失效登录页重定向）")]),t._v(" "),_("p",[t._v("304 资源未修改")]),t._v(" "),_("p",[t._v("400 请求报文出现语法错误")]),t._v(" "),_("p",[t._v("401 未授权")]),t._v(" "),_("p",[t._v("403 服务器拒绝请求")]),t._v(" "),_("p",[t._v("404 资源未找到")]),t._v(" "),_("p",[t._v("405 方法禁止")]),t._v(" "),_("p",[t._v("408 请求超时")]),t._v(" "),_("p",[t._v("500 服务器错误")]),t._v(" "),_("p",[t._v("501 服务器不具备处理请求的方法")]),t._v(" "),_("p",[t._v("502 网关错误")]),t._v(" "),_("p",[t._v("503 服务不可用")]),t._v(" "),_("p",[t._v("505 http协议不支持")]),t._v(" "),_("h2",{attrs:{id:"三次握手与四次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三次握手与四次挥手"}},[t._v("#")]),t._v(" 三次握手与四次挥手")]),t._v(" "),_("h3",{attrs:{id:"三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[t._v("#")]),t._v(" 三次握手")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[t._v("  刚开始客户端处于 closed 的状态，服务端处于 listen 状态。然后\n      1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN（c）。此时客户端处于 SYN_Send 状态。\n      2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。\n  \t  3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。\n      4、服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。\n")])])]),_("p",[_("img",{attrs:{src:s(299),alt:"img"}})]),t._v(" "),_("h3",{attrs:{id:"四次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[t._v("#")]),t._v(" 四次挥手")]),t._v(" "),_("p",[t._v("刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[t._v("  1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。\n\n  2、第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。\n\n  3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。\n\n  4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态\n\n  5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。\n")])])]),_("h2",{attrs:{id:"get和post请求的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#get和post请求的区别"}},[t._v("#")]),t._v(" get和post请求的区别")]),t._v(" "),_("ol",[_("li",[t._v("get的请求参数放在 url，而post的请求参数放在body里面，安全性相对更好")]),t._v(" "),_("li",[t._v("get请求主要用于获取数据，post请求用于提交表单")]),t._v(" "),_("li",[t._v("get请求在浏览器回退时是无害的，post在回退时会再次提交请求")]),t._v(" "),_("li",[t._v("get请求会被浏览器主动缓存，post需要手动设置")]),t._v(" "),_("li",[t._v("GET请求在URL中传送的参数是有长度限制的，而POST没有。")]),t._v(" "),_("li",[t._v("GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。")]),t._v(" "),_("li",[t._v("GET请求只能进行url编码，而POST支持多种编码方式。")]),t._v(" "),_("li",[t._v("GET产生一个TCP数据包；POST产生两个TCP数据包，即先发送header收到服务器connection确认后，再发送data")])])])}),[],!1,null,null,null);_.default=a.exports}}]);